Perfect ðŸŽ‰ now that parsing works, youâ€™re in control. Letâ€™s turn this into a proper **observability workflow** that meets your original goals:

---
fields @timestamp, @message
| parse @message /User ID:\s*(?<userId>[^\s"]+)/
| parse @message /RequestUri:\s*(?<requestUri>[^\s"]+)/
| parse @message /Status:\s*(?<status>\d{3})/
| parse @message /Total Time Taken:\s*(?<totalTime>\d+)/
| parse @message /[?&]countryCode=(?<countryCode>[^&\s"]+)/
| display @timestamp, userId, requestUri, status, totalTime, countryCode
| sort @timestamp desc
| limit 200



# âœ… Step 1: Parsing fields (done!)

Your query is already extracting:

* `userId`
* `requestUri`
* `status`
* `totalTime`
* `countryCode`

You can add more fields later (`cropEppoCode`, `diseaseEppoCode`, `mode`) by stacking extra `parse` lines.

---

# âœ… Step 2: Create core queries for metrics

### A. Monthly request volume (overall)

```sql
fields @timestamp
| stats count() as totalRequests by bin(30d, @timestamp)
| sort @timestamp asc
```

ðŸ“Š Visualization: **Line chart**

---

### B. Monthly requests by API path

```sql
fields @timestamp, requestUri
| stats count() as requests by bin(30d, @timestamp), requestUri
| sort @timestamp asc, requests desc
```

ðŸ“Š Visualization: **Stacked area** (shows breakdown per URI)

---

### C. Requests by country

```sql
fields @timestamp, countryCode
| filter @timestamp >= ago(30d)
| stats count() as requests by countryCode
| sort requests desc
| limit 10
```

ðŸ“Š Visualization: **Bar chart** (Top 10 countries)

---

### D. Latency metrics

```sql
fields @timestamp, requestUri, totalTime
| stats 
    avg(to_number(totalTime)) as avgMs,
    pct(to_number(totalTime), 90) as p90Ms,
    pct(to_number(totalTime), 99) as p99Ms
  by bin(30d, @timestamp), requestUri
| sort @timestamp asc
```

ðŸ“Š Visualization: **Line chart** (choose avg or p90)

---

### E. Error rates

```sql
fields @timestamp, status, requestUri
| stats 
    count() as total,
    sum(if(substr(status,0,1)='5',1,0)) as errors
  by bin(30d, @timestamp), requestUri
| eval errorRate = errors * 100.0 / total
| sort @timestamp asc
```

ðŸ“Š Visualization: **Line chart**

---

# âœ… Step 3: Save queries as widgets

In **CloudWatch Logs Insights**:

1. Run a query.
2. Click **Add to dashboard**.
3. Pick **Visualization** â†’ Table/Line/Bar/Stacked.
4. Add to your dashboard.

Repeat for each query above. Youâ€™ll end up with:

* Line chart â†’ total requests/month
* Stacked area chart â†’ per-URI breakdown
* Bar chart â†’ Top countries
* Line chart â†’ Latency
* Line chart â†’ Error rate

---

# âœ… Step 4: Make dashboard interactive

CloudWatch doesnâ€™t have free-text filters in dashboards, but you can:

* Add **multiple widgets** with different filters (e.g., `| filter countryCode = 'IN'`).
* Clone widgets and change filters for specific `userId`, `requestUri`, or `status`.
* Use **time range controls** (top-right) to zoom into 1d/1w/3m.

If you need **real search** (like â€œfind all logs with keywordâ€), export to **Amazon OpenSearch Service (Elasticsearch)**. There youâ€™ll get dashboards with full search + drilldown.

---

# âœ… Step 5: Optional â€” Create CloudWatch Metrics

If you want alarms/alerts:

1. Go to **Log group â†’ Metric filter**.
2. Define filter pattern to extract `requestUri`/`status`.
3. Publish to **CloudWatch custom metric**.
4. Use these metrics in **alarms** (e.g., alert if p95 > 5s or errorRate > 5%).

---

# ðŸ”œ Your Next Steps

1. Decide: **Dashboard-only** (good for monitoring & trends) OR **Custom metrics + alarms** (good for alerting).
2. Add widgets for:

   * Monthly totals
   * Breakdown per URI
   * Top countries
   * Latency percentiles
   * Error rates
3. Clone widgets with filters for key `userId` or endpoints you care about.

---

ðŸ‘‰ Do you want me to generate a **ready-to-paste Dashboard JSON** with all 5 widgets (queries above), so you donâ€™t have to add them one by one manually?

